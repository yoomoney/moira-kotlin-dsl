package ru.yandex.money.moira.dsl.triggers

import org.json.JSONArray
import org.json.JSONObject
import ru.yandex.money.moira.dsl.triggers.expression.TriggerExpression
import ru.yandex.money.moira.dsl.triggers.expression.TriggerType
import ru.yandex.money.moira.dsl.triggers.json.Json
import ru.yandex.money.moira.dsl.triggers.json.json
import ru.yandex.money.moira.dsl.triggers.schedule.Schedule
import ru.yandex.money.moira.dsl.triggers.targets.Target
import ru.yandex.money.moira.dsl.triggers.targets.TargetDelegate
import ru.yandex.money.moira.dsl.triggers.ttl.Ttl

/**
 * A trigger in Moira.
 */
class Trigger(
    /**
     * An ID of trigger.
     *
     * May be `null`. In such case it will be randomly generated by Moira.
     */
    private val id: String?,
    /**
     * A name of trigger that will be displayed in Moira GUI.
     */
    private val name: String,
    /**
     * A description of trigger. It may included any text that describes what kind of metric this trigger is build for,
     * or how to fix problem when trigger has WARN or ERROR state.
     */
    private val description: String?,
    /**
     * A list of target metrics in graphite syntax.
     */
    private val targets: List<Target>,
    /**
     * A list of tags that can be used to group triggers.
     */
    private val tags: List<String>,
    /**
     * An expression that defines condition to fire up trigger.
     */
    private val expression: TriggerExpression,
    /**
     * A time-to-live parameters.
     */
    private val ttl: Ttl,
    /**
     * A schedule for trigger watch time.
     */
    private val schedule: Schedule
) : Json {

    init {
        if (targets.isEmpty()) {
            throw IllegalStateException("Targets must not be empty")
        }
        if (expression.type != TriggerType.EXPRESSION && targets.size > 1) {
            throw IllegalStateException("When using simple mode only 1 target metric must be defined")
        }
        if (tags.isEmpty()) {
            throw IllegalStateException("Tags must not be empty")
        }
    }

    override fun toJson(): JSONObject = json {
        if (id != null) {
            "id" to id
        }
        "name" to name
        if (description != null) {
            "desc" to description
        }
        "targets" to targets.map { it.metric }
        "tags" to tags
        +expression
        +ttl
        "sched" to schedule
    }

    /**
     * Builder for [Trigger].
     */
    @MoiraDsl
    class Builder(private val id: String?, private val name: String) {

        var description: String? = null

        private val targets = mutableListOf<Target>()

        val tags = mutableListOf<String>()

        private lateinit var expression: TriggerExpression

        private val ttlBuilder = Ttl.Builder()

        private val scheduleBuilder = Schedule.Builder()

        /**
         * Returns delegate for [Target] local variable.
         */
        fun target(metric: String) = TargetDelegate(metric, targets)

        /**
         * Sets up expression for trigger.
         */
        fun expression(build: TriggerExpression.Builder.() -> TriggerExpression) {
            val builder = TriggerExpression.Builder()
            expression = builder.build()
        }

        /**
         * Sets up time-to-live parameters.
         */
        fun ttl(build: Ttl.Builder.() -> Unit) {
            ttlBuilder.build()
        }

        /**
         * Sets up watch time schedule.
         */
        fun schedule(build: Schedule.Builder.() -> Unit) {
            scheduleBuilder.build()
        }

        /**
         * Creates trigger.
         */
        fun asTrigger() = Trigger(
            id = id,
            name = name,
            description = description,
            targets = targets,
            tags = tags,
            expression = expression,
            ttl = ttlBuilder.asTtl(),
            schedule = scheduleBuilder.asSchedule()
        )
    }

    /**
     * Builder for collection of [Trigger].
     */
    @MoiraDsl
    class TriggersBuilder {

        private val triggers = mutableListOf<Trigger>()

        /**
         * Creates a trigger.
         */
        fun trigger(id: String? = null, name: String, build: Trigger.Builder.() -> Unit) {
            val builder = Trigger.Builder(id = id, name = name)
            builder.build()
            triggers += builder.asTrigger()
        }

        /**
         * Returns list of triggers.
         */
        fun asTriggers(): List<Trigger> = triggers
    }
}

/**
 * Creates a trigger. This is high level function that must be used to create single triggers by DSL.
 *
 * Returns string representation of JSON objects that describes trigger.
 */
fun trigger(id: String? = null, name: String, build: Trigger.Builder.() -> Unit): String {
    val builder = Trigger.Builder(id = id, name = name)
    builder.build()
    return builder.asTrigger().toJson().toString()
}

/**
 * Creates a collection of trigger. This is high level function that must be used to create lists of triggers by DSL.
 *
 * Returns string representation of JSON array with triggers.
 */
fun triggers(build: Trigger.TriggersBuilder.() -> Unit): String {
    val builder = Trigger.TriggersBuilder()
    builder.build()
    val triggers = builder.asTriggers()
    return JSONArray(triggers.map { it.toJson() }).toString()
}
